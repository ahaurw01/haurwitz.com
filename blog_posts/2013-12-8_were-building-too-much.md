{{{
  "title": "We're building too much",
  "date": "Feb 9, 2014"
}}}

We've all been there. You've got a great idea for a new side project. A couple friends are getting together to start a new venture. Management and Product have come up with The Answer The Market Is Looking Forâ„¢. I'm talking about the beginning of a new product/feature/thing. If there's anything in common with all new undertakings, it's the desire to build too much at the beginning. This is a problem I see affecting the entire software industry - from pet projects to multi-billion dollar ventures - and all aspects of development - from how we construct the most low-level solutions for requirements to how high-level requirements are constructed.<!--more-->

The main idea I hope to get across is this: we're all going to be better off if we attempt to solve fewer problems at the onset of a new project. Trying to do too much for version 1 of your product can be disastrous in so many ways - development time lost, high opportunity costs incurred for not getting your product in the hands of potential consumers, and, most important to me as a developer, stakeholder frustration.

### Close your eyes...

Play along with me for a second and imagine that you're in the situation I've described. You or your company are about to begin the journey of this totally awesome new project. You have a fair idea of what you need to build in order to say that you have met the goals of this project. Let's say you've come up with a gut estimate of a month to build this new thing. Cool. You want to dive in and see where things are in a month. Not so fast, Greg Louganis. In this make-believe scenario you just got an order from your CEO, investors, mother, or whatever body of authority you care to imagine. A month is not going to cut it. They want the initial version of this solution in three days.

> ...what is the absolute minimum viable product?

After you're done telling your mom how unfair that sounds, you gotta come up with a plan. My guess is that your plan is not going to just include a near-lethal combination of energy drinks, beer, and circular Italian foodstuffs. Your first thought is probably, "Okay, then what is the absolute minimum viable product I can scrape together to say that I've addressed the concerns responsible for this idea in the first place?" Forcing yourself to think this way imposes an extreme focus on the project. All of a sudden, you can tell exactly what is necessary for you to work on in those three days and what can wait.

Put your imagining hat back on. In this next scenario, the order of operations is reversed. The project idea is hatched. The initial goals are floated by the team and a month is the decided ETA. You chime in. "Guys, check it out. If we distill the ask down to its bare bones and deliver just that, it'll take three days. Then we can get back to work and spend the next 27 days seeing how we did and filling in the gaps." "That's a great idea, Greg! Let's dive in."

> You're able to get feedback as early as possible.

Why does the reversed scenario sound so good? Most importantly, you're able to get feedback as early as possible. As soon as your product is functional, it should (by definition of your project) be providing some sort of value. Getting that value in the hands of other people as early as possible is intuitively important. You can get insider and outsider opinions on whether or not it is solving the problem you saw in the way you hoped. If all has gone well and you hit your initial goals, you will have set yourself up for early success. All that you need now is to iterate on your solution and build it up further. On the flip side, it is easy to imagine the worst-case scenario at this point in development: you failed. What you built does not provide the value you hoped. Fine! You spent three days instead of 30 to find that out. You can adjust course. You can even fail 10 times in a row and have spent the same amount of time failing once had you not optimized your initial development.

The idea I'm getting at here is that this kind of focus is essential to a fledgling project. Describe exactly what problems you want to solve first so you can know exactly what value you're trying to offer. At the beginning of a project, all those involved should be keenly aware of why they're building the product. Even if the project is as small as a blog for poor web development-related jokes, what you're doing is novel, right? Otherwise you wouldn't be doing it. Finding out exactly what is novel and important about your project is where your focus should be.

### Impossible to see the future is

As soon as a new project is underway, minds race. "What's going to happen when we start getting all those millions of widget orders every day instead of just a handful?" "What am I going to do when there are more search results than can be comfortably viewed within one page?" "But what if somebody wants to access my website on a Palm VII using a dial-up connection from the International Space Station?" This is good. For known future needs, it is nice to have certain concerns in mind when architecting a new product.

> Why waste time solving problems now that you may never have in the future?

But you don't know if all the "what ifs" will ever come to fruition. Nobody knows. Your walks-on-water CEO could be totally wrong about his or her vision of the market for your new software product. But the good thing is that you don't need to care right now. You're getting 10 orders a day, so make sure your current system can handle that. You only have a handful of search results on your support page, so don't worry about pagination. Once you figure out that you're missing out on the nostalgic astronaut demographic, you can address those concerns then. Why waste time solving problems now that you may never have in the future?

### You make a lot of mistakes

When's the last time you shipped software without bugs? More like, when's the last time you shipped bugs with some software, amirite?? Everybody makes a ton of mistakes when creating software. I make mistakes that lead to runtime errors, poor optimizations, and less than ideal usability. The product team makes mistakes by asking for things that don't solve the problem in the most ideal way, or worse yet, by asking for things that don't solve the right problem. I would much rather make small mistakes early than larger mistakes later. The longer a project stretches on before a meaningful feedback loop can be connected, the larger your mistakes could be. Everybody is well aware of the "Cost of Fixing a Bug" chart that describes exponential differences between catching a bug in requirements, development, early QA, production, maintenance, etc. I believe that chart becomes even more powerful when you examine and compare the relative lengths of each step of the cycle.

### Going over the edge in a barrel

When the topic of software development methodologies comes up, people are quick to joke about the Waterfall approach as the rigid and ineffective strategy of out-of-touch, bureaucratic government-contracting behemoths. The Waterfall method is akin to how you might imagine a house gets built. There's a blueprint created at the beginning, the contractor teams work one after another according to that plan, and when they're done you get the keys. Once the slab is poured and the framing put up, there's no going back to second-guess the structural layout of the house. Once the keys are turned over to you, ain't nobody coming back to figure out a better way to route the plumbing. Even though we give ourselves fun job titles like Architect, Engineer, and Developer, we're not orchestrating the laying of bricks. Our projects have life and evolve. We refactor code and optimize for discovered use cases. This is why the Waterfall method is looked down upon. As this is becoming universal knowledge within the software development community, we need to remind ourselves why it's good to eschew the complete-blueprint-first approach. I'm not belittling the other engineering professions, but drawing a line of distinction between software and those who build physical things. On the one hand, a concrete artifact is being constructed that is, for all intents and purposes, complete when the family inhabits the house. Software, on the other hand, fills evolving needs. We are able to remodel the house as it is inhabited. We should therefore get our house inhabited as soon as possible.

> If I had more time, I would have written a shorter letter. - Pascal or Locke or Thoreau or somebody

My last point is philosophical in nature. Ever look at the cockpit of a plane? Notice how many knobs and dials there are up there? Have you ever looked at your iPhone? Notice how it's got one button? Okay, so it's got some buttons on the side and actually you could make the argument that a touch screen is like an infinite number of buttons, but now you're just being a smart ass. My point is that a simpler product is more approachable and intuitive. Unless your product has won the user-commitment lottery like Vi or Photoshop (or apparently an airplane), people's lives do not revolve around your product, nor do they care to devote that much energy to it.

> I'd have to ask myself what problems exist that are solved by introducing complexity to the project.

As a developer or a requirements writer, we like to believe that everything we can pack into the product will enhance the users' lives and they will be grateful that they can do more with the product. This is not true. Going back to the three days vs. one month scenario, I can almost guarantee that there is at least one feature you originally included in the one month deliverable that you just never implement at all because you simply don't need it. Take this blog for example. I could have originally set out to implement some sort of paging or archive viewing for old posts, categorization of post topics, a search feature, RSS feed, and online admin functionality. I have none of those things. And you don't care. (Well, whether or not you care about my blog at all is beside the point.) The site is perfectly functional and straightforward without any of that. It fulfills its current needs. If I feel like adding any of those things to my site, I'd have to ask myself what problems exist that are solved by introducing complexity to the project.

### TL;DR

I don't blame you. Congrats for even scrolling all this way down without a repetitive stress injury.

I believe the best approach to a new project is to distill the aim directly into the goals of your first attempt at producing a viable product. Don't imagine problems you may never have. This is not an excuse for lazily architecting your software, though; pay attention to known future needs. Try to get the first version into the hands of stakeholders fast. You're going to mess up, so reduce risk by introducing minimal complexity and gathering feedback sooner.

When you learn that you need to tweak your product to better fit the users' needs, be happy you didn't invest too much time into a solution that was less than ideal. Pat yourself on the back for somebody giving a shit about your software, then get back to work.